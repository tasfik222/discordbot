const { Client, GatewayIntentBits, Partials } = require("discord.js");
require("dotenv").config();

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildVoiceStates
  ],
  partials: [Partials.Channel]
});

// Allowed text channel
const ALLOWED_TEXT_CHANNEL = "";

// Voice channel IDs
const FROM_CHANNEL = "";
const TO_CHANNEL = "";

client.on("messageCreate", async (message) => {
  if (message.author.bot) return;

  // Restrict to specific text channel
  if (message.channel.id !== ALLOWED_TEXT_CHANNEL) return;

  const content = message.content.trim();

  // Case 1: ", all"
  if (content === ", all") {
    const fromChannel = message.guild.channels.cache.get(FROM_CHANNEL);

    if (!fromChannel || fromChannel.members.size === 0) {
      return message.reply("‚ùå ‡¶ì‡¶á voice channel ‡¶è ‡¶ï‡ßá‡¶â ‡¶®‡ßá‡¶á!");
    }

    fromChannel.members.forEach(member => {
      member.voice.setChannel(TO_CHANNEL).catch(() => null);
    });

    return message.reply("‚úÖ FROM channel ‡¶è ‡¶•‡¶æ‡¶ï‡¶æ **‡¶∏‡¶ï‡¶≤‡¶ï‡ßá** move ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá!");
  }

  // Case 2: ", ROLE_ID"
  if (content.startsWith(",") && !content.includes("<@") && content !== ", all") {
    const roleId = content.slice(1).trim();
    const role = message.guild.roles.cache.get(roleId);

    if (!role) return message.reply("‚ùå Role ID ‡¶∏‡¶†‡¶ø‡¶ï ‡¶®‡ßü!");

    const fromChannel = message.guild.channels.cache.get(FROM_CHANNEL);

    if (!fromChannel) return message.reply("‚ùå Voice channel ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø!");

    const membersToMove = fromChannel.members.filter(m => m.roles.cache.has(roleId));

    if (membersToMove.size === 0) {
      return message.reply("‚ùå ‡¶ì‡¶á role-‡¶è‡¶∞ ‡¶ï‡ßá‡¶â ‡¶ì‡¶á voice channel ‡¶è ‡¶®‡ßá‡¶á!");
    }

    membersToMove.forEach(member => {
      member.voice.setChannel(TO_CHANNEL).catch(() => null);
    });

    return message.reply(`‚úÖ Role **${role.name}** ‡¶è‡¶∞ ‡¶∏‡¶¶‡¶∏‡ßç‡¶Ø‡¶¶‡ßá‡¶∞ move ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá!`);
  }

  // Case 3: Mention move
  const mentionedUser = message.mentions.members.first();
  if (!mentionedUser) return;

  // Prevent self-move
  if (mentionedUser.id === message.author.id) {
    return message.reply("‚ùå ‡¶§‡ßÅ‡¶Æ‡¶ø ‡¶®‡¶ø‡¶ú‡ßá‡¶ï‡ßá mention ‡¶¶‡¶ø‡ßü‡ßá move ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá ‡¶®‡¶æ!");
  }

  const voiceState = mentionedUser.voice;
  if (!voiceState.channel) {
    return message.reply("‚ùå mentioned user voice channel ‡¶è ‡¶®‡ßá‡¶á!");
  }

  if (voiceState.channelId !== FROM_CHANNEL) {
    return message.reply("‚ùå mentioned user required voice channel ‡¶è ‡¶®‡ßá‡¶á!");
  }

  try {
    await mentionedUser.voice.setChannel(TO_CHANNEL);
    message.reply(`‚úÖ **${mentionedUser.user.tag}** ‡¶ï‡ßá ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá move ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá!`);
  } catch (error) {
    console.error(error);
    message.reply("‚ùå Move ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá!");
  }
});

client.once("ready", () => {
  console.log(`üî• Bot Online: ${client.user.tag}`);
});

client.login(process.env.TOKEN);
